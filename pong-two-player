
#include <ESP8266WiFi.h>
#include <espnow.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

/* ===== OLED ===== */
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
#define D7 13   // fire button

/* ===== INPUT ===== */
#define BTN_PIN D7
#define JOY_PIN A0
#define BUZZER_PIN 12  // D6

/* ===== GAME CONSTANTS ===== */
#define PADDLE_HEIGHT 12
#define PADDLE_WIDTH  2
#define LEFT_PADDLE_X  2
#define RIGHT_PADDLE_X (SCREEN_WIDTH - 4)
#define SCORE_TO_WIN 11
#define BALL_SPEED_X 2

/* ===== TIMING (add this new one) ===== */
unsigned long lastPacketFromPartner = 0;   // updated every time ANY packet arrives from partner
const unsigned long PARTNER_TIMEOUT_MS = 5000;  // 5 seconds

/* ===== GAME STATE ===== */
enum GameState {
  STATE_SEARCHING,
  STATE_READY,
  STATE_PLAYING
};


GameState gameState = STATE_SEARCHING;

/* ===== ROLE ===== */
bool isMaster = false;
bool partnerFound = false;
uint8_t partnerMac[6];
bool roleConflictDetected = false;

/* ===== PADDLES ===== */
/* ===== PADDLES (updated globals) ===== */
int paddleLeftY = 26;
int paddleRightY = 26;
int lastPaddleLeftY = 26;   // ← ADD THESE
int lastPaddleRightY = 26;  // ← FOR MASTER TRACKING

/* ===== SOUND STATE ===== */
bool soundActive = false;
unsigned long soundEndTime = 0;
int currentSoundFreq = 0;
uint8_t triggered_sound=0;
int shockwavesound=0; // not used but refrenced in sound helper


/* ===== TIMING ===== */
unsigned long lastDiscoverySend = 0;
unsigned long lastInputSend = 0;

uint8_t scoreLeft  = 0;
uint8_t scoreRight = 0;


/* ===== PACKETS ===== */
#define PKT_DISCOVERY 0x01
#define PKT_INPUT     0x02
#define PKT_READY 0x03
#define PKT_STATE 0x04
#define PKT_FORCE_READY 0x05
#define PKT_YOUARECLIENT 0x06

/* sound triggers*/
#define TRIGGER_SOUND_NONE 0x00
#define TRIGGER_SOUND_BOUNCE 0x01


struct DiscoveryPacket {
  uint8_t type;
  uint8_t nonce;
};

struct InputPacket {
  uint8_t type;           // PKT_INPUT
  int8_t paddleY;
  uint8_t claimedMaster;  // 1 = I think I'm master, 0 = I think I'm client
};

struct ReadyPacket {
  uint8_t type;   // PKT_READY
};


bool localReady  = false;
bool remoteReady = false;

struct StatePacket {
  uint8_t type;
  int8_t ballX;
  int8_t ballY;
  int8_t paddleLeftY;
  int8_t paddleRightY;
  uint8_t scoreLeft;
  uint8_t scoreRight;
  uint8_t sound_trigger;
};

struct ForceReadyPacket {
  uint8_t type;   // PKT_FORCE_READY
  uint8_t scoreLeft;
  uint8_t scoreRight;
};

struct YouAreClient {
  uint8_t type;   // PKT_FORCE_READY
};


#define BALL_SIZE 2

int ballX = SCREEN_WIDTH / 2;
int ballY = SCREEN_HEIGHT / 2;
int ballVX = 2;
int ballVY = 1;


/* ===== RANDOM NONCE ===== */
uint8_t myNonce;
uint8_t peerNonce = 0;


/* ===================================================== */
/* ================== ESP-NOW CALLBACK ================= */
/* ===================================================== */
void onDataRecv(uint8_t *mac, uint8_t *incomingData, uint8_t len) {
  if (len < 1) return;
  uint8_t type = incomingData[0];

  // Ignore discovery once we have a partner (prevents re-triggering)
  if (type == PKT_DISCOVERY && partnerFound) 
    {
    Serial.println("Bogus Discovery packet received");
    return;
    };

  if (partnerFound) {
    // Quick MAC compare (only first 3 bytes for speed, or full 6 if paranoid)
    bool fromPartner = (memcmp(mac, partnerMac, 6) == 0);
    if (fromPartner) {
      lastPacketFromPartner = millis();
      // Optional debug:
      // Serial.print("Packet from partner → timeout reset (type ");
      // Serial.print(type); Serial.println(")");
    }
  }

  if (type == PKT_YOUARECLIENT) {
    if (!partnerFound) {
      memcpy(partnerMac, mac, 6);
      esp_now_add_peer(partnerMac, ESP_NOW_ROLE_COMBO, 1, NULL, 0);
    }
    partnerFound = true;
    isMaster = false;
    gameState = STATE_READY;
    Serial.println("Received YOUARECLIENT → forced to CLIENT role");
    return;
  }

  if (type == PKT_DISCOVERY && !partnerFound) {
    DiscoveryPacket pkt;
    memcpy(&pkt, incomingData, sizeof(pkt));

    memcpy(partnerMac, mac, 6);
    esp_now_add_peer(partnerMac, ESP_NOW_ROLE_COMBO, 1, NULL, 0);

    // I received first → I become MASTER and tell the other to be client
    isMaster = true;
    partnerFound = true;
    gameState = STATE_READY;

    // Immediately force the sender to client role
    YouAreClient force;
    force.type = PKT_YOUARECLIENT;
    esp_now_send(partnerMac, (uint8_t*)&force, sizeof(force));

    Serial.printf("Received discovery first → I am MASTER (sent YouAreClient)\n");
    Serial.printf("  Partner MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",
                  mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
    return;
  }

if (type == PKT_READY) {
  remoteReady = true;
  Serial.printf("Received PKT_READY from partner! remoteReady now true (sender MAC: %02X:%02X:...)\n",
                mac[0], mac[1]);
  return;
}

  if (type == PKT_INPUT && partnerFound) {
    InputPacket pkt;
    memcpy(&pkt, incomingData, sizeof(pkt));

    // Role conflict check
    bool peerClaimsMaster = (pkt.claimedMaster == 1);
    if (peerClaimsMaster == isMaster) {
      // Both claim same role → conflict!
      roleConflictDetected = true;
      Serial.println("ROLE CONFLICT DETECTED — both think same role! Resetting...");
      // Fall through to reset logic below
    }

    // Apply paddle if no conflict
    if (!roleConflictDetected) {
      if (isMaster) {
        paddleRightY = pkt.paddleY;
      } else {
        paddleLeftY = pkt.paddleY;
      }
    }
    return;
  }

  if (type == PKT_STATE) {
    if (isMaster) {
      Serial.println("Error: Received STATE as Master");
    } else {
      StatePacket pkt;
      memcpy(&pkt, incomingData, sizeof(pkt));
      ballX        = pkt.ballX;
      ballY        = pkt.ballY;
      paddleLeftY  = pkt.paddleLeftY;
      paddleRightY = pkt.paddleRightY;
      scoreLeft    = pkt.scoreLeft;
      scoreRight   = pkt.scoreRight;
      process_sound_trigger(pkt.sound_trigger);
      
    }
    return;
  }

  if (type == PKT_FORCE_READY) {
    ForceReadyPacket pkt;
    memcpy(&pkt, incomingData, sizeof(pkt));
    gameState = STATE_READY;
    scoreLeft  = pkt.scoreLeft;
    scoreRight = pkt.scoreRight;
    localReady = remoteReady = false;
    return;
  }
}
/* ===================================================== */
/* ================== ESP-NOW SEND ===================== */
/* ===================================================== */

void sendDiscovery() {
  DiscoveryPacket pkt;
  pkt.type = PKT_DISCOVERY;
  pkt.nonce = myNonce;

  uint8_t broadcastAddr[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
  esp_now_send(broadcastAddr, (uint8_t*)&pkt, sizeof(pkt));
}

void sendInput(int paddleY) {
  InputPacket pkt;
  pkt.type         = PKT_INPUT;
  pkt.paddleY      = paddleY;
  pkt.claimedMaster = isMaster ? 1 : 0;

  esp_now_send(partnerMac, (uint8_t*)&pkt, sizeof(pkt));
}

/* ===================================================== */
/* ================== DISPLAY ========================== */
/* ===================================================== */

void drawPlayfield() {
  display.drawLine(0, 0, SCREEN_WIDTH, 0, WHITE);
  display.drawLine(0, SCREEN_HEIGHT - 1, SCREEN_WIDTH, SCREEN_HEIGHT - 1, WHITE);
}

void drawPaddles() {
  display.fillRect(LEFT_PADDLE_X, paddleLeftY, PADDLE_WIDTH, PADDLE_HEIGHT, WHITE);
  display.fillRect(RIGHT_PADDLE_X, paddleRightY, PADDLE_WIDTH, PADDLE_HEIGHT, WHITE);
}

/* ===================================================== */
/* ================== INPUT ============================ */
/* ===================================================== */

int readPaddleY() {
  int raw = analogRead(JOY_PIN);
  raw = 1023 - raw; // invert
  int y = map(raw, 0, 1023, 1, SCREEN_HEIGHT - PADDLE_HEIGHT - 1);
  return y;
}

/* helpers*/
void sendReady() {
  ReadyPacket pkt;
  pkt.type = PKT_READY;
  esp_now_send(partnerMac, (uint8_t*)&pkt, sizeof(pkt));
}

void sendState() {
  StatePacket pkt;
  pkt.type = PKT_STATE;
  pkt.ballX = ballX;
  pkt.ballY = ballY;
  pkt.paddleLeftY = paddleLeftY;
  pkt.paddleRightY = paddleRightY;
  pkt.scoreLeft = scoreLeft;
  pkt.scoreRight = scoreRight;
  pkt.sound_trigger=triggered_sound;

  esp_now_send(partnerMac, (uint8_t*)&pkt, sizeof(pkt));
  triggered_sound=TRIGGER_SOUND_NONE; // only sendthe triggerd sound once. 
}


void drawBall() {
  display.fillRect(ballX, ballY, BALL_SIZE, BALL_SIZE, WHITE);
}

void resetBall(bool towardLeft) {

  // ----- WIN CHECK -----
  if (scoreLeft > 10 || scoreRight > 10) {

    gameState = STATE_READY;

    localReady  = false;
    remoteReady = false;

    sendForceReady();
    return;   // DO NOT spawn a new ball
  }

  // ----- NORMAL BALL RESET -----
  ballX = SCREEN_WIDTH / 2;
  ballY = random(10, SCREEN_HEIGHT - 10);

  ballVX = towardLeft ? -BALL_SPEED_X : BALL_SPEED_X;
  ballVY = random(-2, 3);
  if (ballVY == 0) ballVY = 1;
}


void drawScores() {
  display.setTextSize(1);
  display.setTextColor(WHITE);

  display.setCursor(12, 2);
  display.print(scoreLeft);
  if (isMaster){
    display.print(" M");
  }
  else 
  {
    display.print(" C");
  }

  display.setCursor(SCREEN_WIDTH - 15, 2);
  display.print(scoreRight);
}

void sendForceReady() {
  ForceReadyPacket pkt;
  pkt.type = PKT_FORCE_READY;
  pkt.scoreLeft = scoreLeft;
  pkt.scoreRight = scoreRight;
  esp_now_send(partnerMac, (uint8_t*)&pkt, sizeof(pkt));
}

/* sound functions */

void startSound(int freq, unsigned long durationMs) {
  if (soundActive) return;   // don't interrupt existing sound

  currentSoundFreq = freq;
  soundEndTime = millis() + durationMs;
  soundActive = true;

  tone(BUZZER_PIN, freq);
}

void fireSound() {
  startSound(2200, 40);   // short, sharp laser
  triggered_sound=TRIGGER_SOUND_BOUNCE;
}

void updateSound() {
  if (shockwavesound>0) {
    // Static / buzz effect
    int jitter = random(-100, 300);
    tone(BUZZER_PIN, 600 + jitter);
  };


  if (soundActive && millis() >= soundEndTime) {
    noTone(BUZZER_PIN);
    soundActive = false;
    shockwavesound=0;
  }
}

void process_sound_trigger(uint8_t trigger){
 if (TRIGGER_SOUND_NONE == trigger){return;};
 if (TRIGGER_SOUND_BOUNCE == trigger){
   fireSound();
  return;
 }

}

/* ===================================================== */
/* ================== SETUP ============================ */
/* ===================================================== */

void setup() {
  pinMode(BTN_PIN, INPUT_PULLUP);
  pinMode(BUZZER_PIN, OUTPUT);

  Serial.begin(9600);
  //delay(2000);               // give USB time to enumerate
  Serial.println("\n\n===== ESP8266 Pong starting =====");
  Serial.flush();           // force send

 WiFi.mode(WIFI_STA);
WiFi.disconnect();
delay(100);



  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    for (;;);
  }

  display.clearDisplay();
  display.display();

  if (esp_now_init() != 0) {
    Serial.println("ESP-NOW init failed");
    return;
  }

  esp_now_set_self_role(ESP_NOW_ROLE_COMBO);
  esp_now_register_recv_cb(onDataRecv);

  randomSeed(ESP.getChipId());
  myNonce = random(1, 255);
      Serial.print("My nonce = ");
    Serial.println(myNonce);
    // in setup, after myNonce print:
Serial.println("Discovery broadcasts every ~800 ms until partner found");
}

/* ===================================================== */
/* ================== LOOP ============================= */
/* ===================================================== */

void loop() {

/* ===== READ LOCAL PADDLE ===== */
int localPaddleY = readPaddleY();

if (isMaster) {
  paddleLeftY = localPaddleY;
} else {
  paddleRightY = localPaddleY;
}

// Check for detected conflict (from incoming INPUT)
if (roleConflictDetected && partnerFound) {
  partnerFound = false;
  roleConflictDetected = false;
  gameState = STATE_SEARCHING;
  localReady = remoteReady = false;
  // Optional: clear peer list if you want (but not strictly needed)
  Serial.println("Conflict reset → back to Searching");
}
/* check for timeout */
  if (partnerFound && gameState != STATE_SEARCHING) {
    if (millis() - lastPacketFromPartner > PARTNER_TIMEOUT_MS) {
      Serial.println("No packets from partner for 5s → timeout! Reverting to Searching...");
      partnerFound = false;
      localReady = remoteReady = false;
      roleConflictDetected = false;
      gameState = STATE_SEARCHING;
      // Optional: reset paddles to center
      paddleLeftY = paddleRightY = 26;
      lastPaddleLeftY = lastPaddleRightY = 26;
    }
  }


  /* ===== SEND INPUT ===== */
  if (partnerFound && millis() - lastInputSend > 30) {
    sendInput(localPaddleY);
    lastInputSend = millis();
  }

  /* ===== DISCOVERY ===== */
if (!partnerFound && millis() - lastDiscoverySend > 800) {  // was 500
  sendDiscovery();
  lastDiscoverySend = millis();
Serial.println("Discovery packet sent");
}

  /* ===== DISPLAY ===== */
/* ===== DISPLAY ===== */
display.clearDisplay();
drawPlayfield();
drawPaddles();   // always draw paddles — looks nice even in ready state

if (gameState == STATE_SEARCHING) {
  display.setCursor(20, 28);
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.print("Searching...");
}

if (gameState == STATE_READY) {
  // Button handling — always run when in READY
  static bool lastBtn = HIGH;
  bool btn = digitalRead(BTN_PIN);

  if (lastBtn == HIGH && btn == LOW && !localReady) {
    localReady = true;
    sendReady();
    Serial.println("Local ready pressed & sent PKT_READY");
  }
  lastBtn = btn;

  // Draw ready screen elements
  display.setCursor(50, 22);
  display.print("Ready?");

  display.setCursor(30, 34);
  display.print(localReady  ? "You: OK" : "You: --");

  display.setCursor(30, 44);
  display.print(remoteReady ? "Them: OK" : "Them: --");

}

if (gameState == STATE_PLAYING) {
  drawBall();
}

// Scores can be shown in READY too (helps debugging)
drawScores();


if (gameState == STATE_READY) {
  if (localReady && remoteReady) {

    if (isMaster) {
      scoreLeft  = 0;
      scoreRight = 0;

      ballX = 10;
      ballY = SCREEN_HEIGHT / 2;
      ballVX = BALL_SPEED_X;
      ballVY = random(-1, 2);
      if (ballVY == 0) ballVY = 1;
    }

    gameState = STATE_PLAYING;
  }
}


if (gameState == STATE_PLAYING && isMaster) {
  // Compute paddle velocities from last frame to current (before physics)
  int leftPaddleVY  = paddleLeftY  - lastPaddleLeftY;
  int rightPaddleVY = paddleRightY - lastPaddleRightY;

  ballX += ballVX;
  ballY += ballVY;

  // Bounce top/bottom
  if (ballY <= 1 || ballY >= SCREEN_HEIGHT - BALL_SIZE - 1) {
    ballVY = -ballVY;
  }

  // ----- LEFT PADDLE COLLISION (ENHANCED) -----
  if (ballVX < 0 &&
      ballX <= LEFT_PADDLE_X + PADDLE_WIDTH &&
      ballX >= LEFT_PADDLE_X &&
      ballY + BALL_SIZE >= paddleLeftY &&
      ballY <= paddleLeftY + PADDLE_HEIGHT) {

    ballVX = -ballVX;

    int hitPos = ballY - paddleLeftY;
    ballVY = map(hitPos, 0, PADDLE_HEIGHT, -2, 2);
    
    // ← ADD: Apply paddle motion to ball
    ballVY += leftPaddleVY * 0.6f;  // 0.6 = tunable factor (try 0.4-0.8)
    ballVY = constrain(ballVY, -4, 4);  // Clamp to sane speeds

    fireSound();
    Serial.print("Left hit! paddleVY="); Serial.print(leftPaddleVY);
    Serial.print(" new ballVY="); Serial.println(ballVY);  // Debug (remove later)
  
  }

  // ----- RIGHT PADDLE COLLISION (ENHANCED) -----
  if (ballVX > 0 &&
      ballX + BALL_SIZE >= RIGHT_PADDLE_X &&
      ballX + BALL_SIZE <= RIGHT_PADDLE_X + PADDLE_WIDTH &&
      ballY + BALL_SIZE >= paddleRightY &&
      ballY <= paddleRightY + PADDLE_HEIGHT) {

    ballVX = -ballVX;

    int hitPos = ballY - paddleRightY;
    ballVY = map(hitPos, 0, PADDLE_HEIGHT, -2, 2);
    
    // ← ADD: Apply paddle motion to ball
    ballVY += rightPaddleVY * 0.6f;  // Same factor
    ballVY = constrain(ballVY, -4, 4);  // Clamp
    fireSound();

    Serial.print("Right hit! paddleVY="); Serial.print(rightPaddleVY);
    Serial.print(" new ballVY="); Serial.println(ballVY);  // Debug (remove later)
  }

  // ----- MISS LEFT -----
  if (ballX < 0) {
    scoreRight++;
    resetBall(true);
  }

  // ----- MISS RIGHT -----
  if (ballX > SCREEN_WIDTH) {
    scoreLeft++;
    resetBall(false);
  }

  sendState();

  // ← ADD: Update last positions for NEXT frame
  lastPaddleLeftY  = paddleLeftY;
  lastPaddleRightY = paddleRightY;
}

if (gameState == STATE_PLAYING) {
  drawBall();
}
drawScores();


  display.display();
  updateSound();

/*static unsigned long lastDebug = 0;
if (millis() - lastDebug > 5000) {
  Serial.printf("State: %d | Partner: %s | Role: %s\n",
                gameState, partnerFound ? "yes" : "no",
                isMaster ? "MASTER" : "CLIENT");
  lastDebug = millis();
} */


}
